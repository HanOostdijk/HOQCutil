% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cap.out.R
\name{cap.out}
\alias{cap.out}
\title{cap.out captures and wraps the output of an expression}
\usage{
cap.out(cmd, lines = NULL, numlines_only = F, se = NULL,
  width = getOption("width"), fixed_wrap = T)
}
\arguments{
\item{cmd}{An expression or character vector}

\item{lines}{Line numbers to select from output. Default: all lines}

\item{numlines_only}{Boolean indicating no wrapping takes place and only the number of lines and the captured output are returned (in a list). Default: FALSE}

\item{se}{Start and End of each line (see details). Default: NULL (whole line)}

\item{width}{Position in each line where wrapping takes place. Default: \code{getOption('width')}}

\item{fixed_wrap}{Boolean indicating if wrapping takes place at a fixed position or takes into account word boundaries. Default: TRUE}
}
\description{
cap.out captures and wraps the output of an expression
}
\section{details}{


Prints of XML documents can be very lengthy. Therefore I defined the function \code{cap.out} as a cover function of \code{capture.output}. With the argument \code{lines} one can specify the numbers of the lines that will be kept. For each line of output it can specified which part will be displayed. When the argument \code{se} is a 2-column matrix it specifies the start and end of the part. When \code{se} is an integer vector it gives the start position of the part when a number is negative and the end position when a number is postive. In those cases the part extends to the end or from the start of the line. When a number is 0, the line is not displayed. When \code{se} is not specified, all characters for all selected lines will be displayed.
To ensure that the specification of the lines and the positions match I will recycle the position  specification when necessary.
}

\section{acknowledgements}{

I was glad to be able to use the following (idea for) code :
\itemize{
\item the StackOverflow code to recycle argument by \href{https://stackoverflow.com/questions/9335099/implementation-of-standard-recycling-rules}{baptiste}.
\item the idea to split long strings in parts I saw in a StackOverflow article by \href{https://stackoverflow.com/questions/32398301/fastest-way-to-split-strings-into-fixed-length-elements-in-r}{akrun}.
}
}

\section{example description}{

In the example I format an xml document.
Here I specify that I want to retrieve at most 1700 characters of these lines and in fact only will output the first 175 characters of each line with exception of the 6th one where I show 1650. I do not specify \code{lines=} but I know that the print of this document has 7 lines, so I could have added the argument \code{lines=1:7}. I also do not specify \code{width} and therefore use the default system option \code{getOption('width')}.
Both the \code{print} and the \code{cap.out} outputs indicate with \code{...} that a line is truncated; I ensure that the \code{width} of the \code{print} statement is a little greater than the greatest \code{se} to avoid outputs such as \code{'.. ...'} .
}

\examples{
\dontrun{
# see description in details
cap.out( print(xml_doc,width=1700),se=c(175,175,175,175,175,1650,175) )
}
}
