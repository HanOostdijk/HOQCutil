% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mfe_lookup.R
\name{mfe_lookup}
\alias{mfe_lookup}
\title{match first entry in lookup table}
\usage{
mfe_lookup(
  datavec,
  lookup_df,
  lookup_search_col = 1,
  lookup_result_col = 2,
  default = TRUE,
  case_sensitive = FALSE
)
}
\arguments{
\item{datavec}{Character vector with elements that are to be matched in lookup table}

\item{lookup_df}{Data.frame containing a search and a result column}

\item{lookup_search_col}{Integer indicating the number of the search column (in \code{lookup_df})}

\item{lookup_result_col}{Integer indicating the number of the result column (in \code{lookup_df})}

\item{default}{Boolean or character string indicating the value to use when no match is found (See \strong{Details})}

\item{case_sensitive}{Boolean indicating if the match is case sensitive}
}
\value{
Character vector with the same length as \code{datavec} with the result of the match
}
\description{
Returns for the entries in a vector the first entry in the lookup table \code{lookup_df}
that matches the entry or in case of no-match a default. See \strong{Details}
}
\section{Details}{

Each element in \code{datavec} is compared with the elements in the \code{lookup_search_col} column of the \code{lookup_df} data.frame. This is done with a expression of the form  \code{grepl(.,.,fixed=T)} where the first dot represents an element of the \code{lookup_search_col} column and the second dot the \code{datavec} element (both after capitalizing the character strings when \code{case_sensitive==F}). The element of the \code{lookup_search_col} column can contain more than one element and in that case for each element a match must be found. In the example below a match is found for the fourth element if the data element matches both \code{x3} and \code{x4}. If a match is found the corresponding element in the \code{lookup_result_col} column is returned and when more matches are found only the \strong{first} is returned. So for the first element in \code{datavec} we return 'one' and not 'two': 'x1' matches \strong{first} even when you could say that 'x1;x2' matches more. Therefore the more specified case should be specified first: see e.g. the 'x3;x4' case in the example. \cr
For an entry without a match will be returned:
\itemize{
\item the entry itself when \code{default == TRUE} (the default)
\item the empty string when \code{default == FALSE}
\item the contents of \code{default} when \code{default} is not a boolean
}
}

\examples{
\dontrun{
lookup_df = tibble::tribble(
  ~col1, ~col2,
  'x1' , 'one' ,
  'x1;x2' , 'two' ,
  'X2' , 'two' ,
  'x3;x4' , 'three four' ,
  'x3' , 'three'
)  \%>\%
  transform(col1 = strsplit(col1, ";"))

datavec = c('x1 and x2', 'only x2', 'x5', 'x3 and x4','x3 and x5')

mfe_lookup(datavec,lookup_df,default=TRUE)
# c("one", "two", "x5", "three four", "three" )

mfe_lookup(datavec,lookup_df,default=FALSE)
# c("one", "two", "", "three four", "three" )

mfe_lookup(datavec,lookup_df,default='not found!')
# c("one", "two", "not found!", "three four", "three" )

mfe_lookup(datavec,lookup_df,case_sensitive=TRUE)
# c("one", "only x2", "x5", "three four", "three" )

}

}
